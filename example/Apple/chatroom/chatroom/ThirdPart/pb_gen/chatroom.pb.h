// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: chatroom.proto

#ifndef PROTOBUF_chatroom_2eproto__INCLUDED
#define PROTOBUF_chatroom_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_chatroom_2eproto();
void protobuf_AssignDesc_chatroom_2eproto();
void protobuf_ShutdownFile_chatroom_2eproto();

class EnterRoomReq;
class EnterRoomRsp;
class MemberEnter;
class UpMessage;
class DownMessage;
class ExitRoomReq;
class ExitRoomRsp;
class Message;

enum Message_MessageType {
  Message_MessageType_ENTER_ROOM_REQ = 1,
  Message_MessageType_ENTER_ROOM_RSP = 2,
  Message_MessageType_MEMBER_ENTER = 3,
  Message_MessageType_UP_MESSAGE = 4,
  Message_MessageType_DOWN_MESSAGE = 5,
  Message_MessageType_EXIT_ROOM_REQ = 6,
  Message_MessageType_EXIT_ROOM_RSP = 7
};
bool Message_MessageType_IsValid(int value);
const Message_MessageType Message_MessageType_MessageType_MIN = Message_MessageType_ENTER_ROOM_REQ;
const Message_MessageType Message_MessageType_MessageType_MAX = Message_MessageType_EXIT_ROOM_RSP;
const int Message_MessageType_MessageType_ARRAYSIZE = Message_MessageType_MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Message_MessageType_descriptor();
inline const ::std::string& Message_MessageType_Name(Message_MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Message_MessageType_descriptor(), value);
}
inline bool Message_MessageType_Parse(
    const ::std::string& name, Message_MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Message_MessageType>(
    Message_MessageType_descriptor(), name, value);
}
// ===================================================================

class EnterRoomReq : public ::google::protobuf::Message {
 public:
  EnterRoomReq();
  virtual ~EnterRoomReq();

  EnterRoomReq(const EnterRoomReq& from);

  inline EnterRoomReq& operator=(const EnterRoomReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnterRoomReq& default_instance();

  void Swap(EnterRoomReq* other);

  // implements Message ----------------------------------------------

  EnterRoomReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnterRoomReq& from);
  void MergeFrom(const EnterRoomReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string roomName = 1;
  inline bool has_roomname() const;
  inline void clear_roomname();
  static const int kRoomNameFieldNumber = 1;
  inline const ::std::string& roomname() const;
  inline void set_roomname(const ::std::string& value);
  inline void set_roomname(const char* value);
  inline void set_roomname(const char* value, size_t size);
  inline ::std::string* mutable_roomname();
  inline ::std::string* release_roomname();
  inline void set_allocated_roomname(::std::string* roomname);

  // optional string nickName = 2;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNickNameFieldNumber = 2;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // @@protoc_insertion_point(class_scope:proto.EnterRoomReq)
 private:
  inline void set_has_roomname();
  inline void clear_has_roomname();
  inline void set_has_nickname();
  inline void clear_has_nickname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* roomname_;
  ::std::string* nickname_;
  friend void  protobuf_AddDesc_chatroom_2eproto();
  friend void protobuf_AssignDesc_chatroom_2eproto();
  friend void protobuf_ShutdownFile_chatroom_2eproto();

  void InitAsDefaultInstance();
  static EnterRoomReq* default_instance_;
};
// -------------------------------------------------------------------

class EnterRoomRsp : public ::google::protobuf::Message {
 public:
  EnterRoomRsp();
  virtual ~EnterRoomRsp();

  EnterRoomRsp(const EnterRoomRsp& from);

  inline EnterRoomRsp& operator=(const EnterRoomRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnterRoomRsp& default_instance();

  void Swap(EnterRoomRsp* other);

  // implements Message ----------------------------------------------

  EnterRoomRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnterRoomRsp& from);
  void MergeFrom(const EnterRoomRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline ::google::protobuf::int32 error() const;
  inline void set_error(::google::protobuf::int32 value);

  // optional uint32 ID = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 2;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.EnterRoomRsp)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 error_;
  ::google::protobuf::uint32 id_;
  friend void  protobuf_AddDesc_chatroom_2eproto();
  friend void protobuf_AssignDesc_chatroom_2eproto();
  friend void protobuf_ShutdownFile_chatroom_2eproto();

  void InitAsDefaultInstance();
  static EnterRoomRsp* default_instance_;
};
// -------------------------------------------------------------------

class MemberEnter : public ::google::protobuf::Message {
 public:
  MemberEnter();
  virtual ~MemberEnter();

  MemberEnter(const MemberEnter& from);

  inline MemberEnter& operator=(const MemberEnter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MemberEnter& default_instance();

  void Swap(MemberEnter* other);

  // implements Message ----------------------------------------------

  MemberEnter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MemberEnter& from);
  void MergeFrom(const MemberEnter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional string nickName = 2;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNickNameFieldNumber = 2;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // @@protoc_insertion_point(class_scope:proto.MemberEnter)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_nickname();
  inline void clear_has_nickname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* nickname_;
  ::google::protobuf::uint32 id_;
  friend void  protobuf_AddDesc_chatroom_2eproto();
  friend void protobuf_AssignDesc_chatroom_2eproto();
  friend void protobuf_ShutdownFile_chatroom_2eproto();

  void InitAsDefaultInstance();
  static MemberEnter* default_instance_;
};
// -------------------------------------------------------------------

class UpMessage : public ::google::protobuf::Message {
 public:
  UpMessage();
  virtual ~UpMessage();

  UpMessage(const UpMessage& from);

  inline UpMessage& operator=(const UpMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpMessage& default_instance();

  void Swap(UpMessage* other);

  // implements Message ----------------------------------------------

  UpMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpMessage& from);
  void MergeFrom(const UpMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes message = 1;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 1;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const void* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // optional int32 length = 2;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 2;
  inline ::google::protobuf::int32 length() const;
  inline void set_length(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.UpMessage)
 private:
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_length();
  inline void clear_has_length();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* message_;
  ::google::protobuf::int32 length_;
  friend void  protobuf_AddDesc_chatroom_2eproto();
  friend void protobuf_AssignDesc_chatroom_2eproto();
  friend void protobuf_ShutdownFile_chatroom_2eproto();

  void InitAsDefaultInstance();
  static UpMessage* default_instance_;
};
// -------------------------------------------------------------------

class DownMessage : public ::google::protobuf::Message {
 public:
  DownMessage();
  virtual ~DownMessage();

  DownMessage(const DownMessage& from);

  inline DownMessage& operator=(const DownMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DownMessage& default_instance();

  void Swap(DownMessage* other);

  // implements Message ----------------------------------------------

  DownMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DownMessage& from);
  void MergeFrom(const DownMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes message = 1;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 1;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const void* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // optional int32 length = 2;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 2;
  inline ::google::protobuf::int32 length() const;
  inline void set_length(::google::protobuf::int32 value);

  // optional string nickName = 3;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNickNameFieldNumber = 3;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // @@protoc_insertion_point(class_scope:proto.DownMessage)
 private:
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_nickname();
  inline void clear_has_nickname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* message_;
  ::std::string* nickname_;
  ::google::protobuf::int32 length_;
  friend void  protobuf_AddDesc_chatroom_2eproto();
  friend void protobuf_AssignDesc_chatroom_2eproto();
  friend void protobuf_ShutdownFile_chatroom_2eproto();

  void InitAsDefaultInstance();
  static DownMessage* default_instance_;
};
// -------------------------------------------------------------------

class ExitRoomReq : public ::google::protobuf::Message {
 public:
  ExitRoomReq();
  virtual ~ExitRoomReq();

  ExitRoomReq(const ExitRoomReq& from);

  inline ExitRoomReq& operator=(const ExitRoomReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExitRoomReq& default_instance();

  void Swap(ExitRoomReq* other);

  // implements Message ----------------------------------------------

  ExitRoomReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExitRoomReq& from);
  void MergeFrom(const ExitRoomReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string roomName = 1;
  inline bool has_roomname() const;
  inline void clear_roomname();
  static const int kRoomNameFieldNumber = 1;
  inline const ::std::string& roomname() const;
  inline void set_roomname(const ::std::string& value);
  inline void set_roomname(const char* value);
  inline void set_roomname(const char* value, size_t size);
  inline ::std::string* mutable_roomname();
  inline ::std::string* release_roomname();
  inline void set_allocated_roomname(::std::string* roomname);

  // optional string nickName = 2;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNickNameFieldNumber = 2;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // @@protoc_insertion_point(class_scope:proto.ExitRoomReq)
 private:
  inline void set_has_roomname();
  inline void clear_has_roomname();
  inline void set_has_nickname();
  inline void clear_has_nickname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* roomname_;
  ::std::string* nickname_;
  friend void  protobuf_AddDesc_chatroom_2eproto();
  friend void protobuf_AssignDesc_chatroom_2eproto();
  friend void protobuf_ShutdownFile_chatroom_2eproto();

  void InitAsDefaultInstance();
  static ExitRoomReq* default_instance_;
};
// -------------------------------------------------------------------

class ExitRoomRsp : public ::google::protobuf::Message {
 public:
  ExitRoomRsp();
  virtual ~ExitRoomRsp();

  ExitRoomRsp(const ExitRoomRsp& from);

  inline ExitRoomRsp& operator=(const ExitRoomRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExitRoomRsp& default_instance();

  void Swap(ExitRoomRsp* other);

  // implements Message ----------------------------------------------

  ExitRoomRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExitRoomRsp& from);
  void MergeFrom(const ExitRoomRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline ::google::protobuf::int32 error() const;
  inline void set_error(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.ExitRoomRsp)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 error_;
  friend void  protobuf_AddDesc_chatroom_2eproto();
  friend void protobuf_AssignDesc_chatroom_2eproto();
  friend void protobuf_ShutdownFile_chatroom_2eproto();

  void InitAsDefaultInstance();
  static ExitRoomRsp* default_instance_;
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  void Swap(Message* other);

  // implements Message ----------------------------------------------

  Message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Message_MessageType MessageType;
  static const MessageType ENTER_ROOM_REQ = Message_MessageType_ENTER_ROOM_REQ;
  static const MessageType ENTER_ROOM_RSP = Message_MessageType_ENTER_ROOM_RSP;
  static const MessageType MEMBER_ENTER = Message_MessageType_MEMBER_ENTER;
  static const MessageType UP_MESSAGE = Message_MessageType_UP_MESSAGE;
  static const MessageType DOWN_MESSAGE = Message_MessageType_DOWN_MESSAGE;
  static const MessageType EXIT_ROOM_REQ = Message_MessageType_EXIT_ROOM_REQ;
  static const MessageType EXIT_ROOM_RSP = Message_MessageType_EXIT_ROOM_RSP;
  static inline bool MessageType_IsValid(int value) {
    return Message_MessageType_IsValid(value);
  }
  static const MessageType MessageType_MIN =
    Message_MessageType_MessageType_MIN;
  static const MessageType MessageType_MAX =
    Message_MessageType_MessageType_MAX;
  static const int MessageType_ARRAYSIZE =
    Message_MessageType_MessageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MessageType_descriptor() {
    return Message_MessageType_descriptor();
  }
  static inline const ::std::string& MessageType_Name(MessageType value) {
    return Message_MessageType_Name(value);
  }
  static inline bool MessageType_Parse(const ::std::string& name,
      MessageType* value) {
    return Message_MessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .proto.Message.MessageType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::proto::Message_MessageType type() const;
  inline void set_type(::proto::Message_MessageType value);

  // optional .proto.EnterRoomReq enterRoomReq = 2;
  inline bool has_enterroomreq() const;
  inline void clear_enterroomreq();
  static const int kEnterRoomReqFieldNumber = 2;
  inline const ::proto::EnterRoomReq& enterroomreq() const;
  inline ::proto::EnterRoomReq* mutable_enterroomreq();
  inline ::proto::EnterRoomReq* release_enterroomreq();
  inline void set_allocated_enterroomreq(::proto::EnterRoomReq* enterroomreq);

  // optional .proto.EnterRoomRsp enterRoomRsp = 3;
  inline bool has_enterroomrsp() const;
  inline void clear_enterroomrsp();
  static const int kEnterRoomRspFieldNumber = 3;
  inline const ::proto::EnterRoomRsp& enterroomrsp() const;
  inline ::proto::EnterRoomRsp* mutable_enterroomrsp();
  inline ::proto::EnterRoomRsp* release_enterroomrsp();
  inline void set_allocated_enterroomrsp(::proto::EnterRoomRsp* enterroomrsp);

  // optional .proto.MemberEnter memberEnter = 4;
  inline bool has_memberenter() const;
  inline void clear_memberenter();
  static const int kMemberEnterFieldNumber = 4;
  inline const ::proto::MemberEnter& memberenter() const;
  inline ::proto::MemberEnter* mutable_memberenter();
  inline ::proto::MemberEnter* release_memberenter();
  inline void set_allocated_memberenter(::proto::MemberEnter* memberenter);

  // optional .proto.UpMessage upMessage = 5;
  inline bool has_upmessage() const;
  inline void clear_upmessage();
  static const int kUpMessageFieldNumber = 5;
  inline const ::proto::UpMessage& upmessage() const;
  inline ::proto::UpMessage* mutable_upmessage();
  inline ::proto::UpMessage* release_upmessage();
  inline void set_allocated_upmessage(::proto::UpMessage* upmessage);

  // optional .proto.DownMessage downMessage = 6;
  inline bool has_downmessage() const;
  inline void clear_downmessage();
  static const int kDownMessageFieldNumber = 6;
  inline const ::proto::DownMessage& downmessage() const;
  inline ::proto::DownMessage* mutable_downmessage();
  inline ::proto::DownMessage* release_downmessage();
  inline void set_allocated_downmessage(::proto::DownMessage* downmessage);

  // optional .proto.ExitRoomReq exitRoomReq = 7;
  inline bool has_exitroomreq() const;
  inline void clear_exitroomreq();
  static const int kExitRoomReqFieldNumber = 7;
  inline const ::proto::ExitRoomReq& exitroomreq() const;
  inline ::proto::ExitRoomReq* mutable_exitroomreq();
  inline ::proto::ExitRoomReq* release_exitroomreq();
  inline void set_allocated_exitroomreq(::proto::ExitRoomReq* exitroomreq);

  // optional .proto.ExitRoomRsp exitRoomRsp = 8;
  inline bool has_exitroomrsp() const;
  inline void clear_exitroomrsp();
  static const int kExitRoomRspFieldNumber = 8;
  inline const ::proto::ExitRoomRsp& exitroomrsp() const;
  inline ::proto::ExitRoomRsp* mutable_exitroomrsp();
  inline ::proto::ExitRoomRsp* release_exitroomrsp();
  inline void set_allocated_exitroomrsp(::proto::ExitRoomRsp* exitroomrsp);

  // @@protoc_insertion_point(class_scope:proto.Message)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_enterroomreq();
  inline void clear_has_enterroomreq();
  inline void set_has_enterroomrsp();
  inline void clear_has_enterroomrsp();
  inline void set_has_memberenter();
  inline void clear_has_memberenter();
  inline void set_has_upmessage();
  inline void clear_has_upmessage();
  inline void set_has_downmessage();
  inline void clear_has_downmessage();
  inline void set_has_exitroomreq();
  inline void clear_has_exitroomreq();
  inline void set_has_exitroomrsp();
  inline void clear_has_exitroomrsp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::EnterRoomReq* enterroomreq_;
  ::proto::EnterRoomRsp* enterroomrsp_;
  ::proto::MemberEnter* memberenter_;
  ::proto::UpMessage* upmessage_;
  ::proto::DownMessage* downmessage_;
  ::proto::ExitRoomReq* exitroomreq_;
  ::proto::ExitRoomRsp* exitroomrsp_;
  int type_;
  friend void  protobuf_AddDesc_chatroom_2eproto();
  friend void protobuf_AssignDesc_chatroom_2eproto();
  friend void protobuf_ShutdownFile_chatroom_2eproto();

  void InitAsDefaultInstance();
  static Message* default_instance_;
};
// ===================================================================


// ===================================================================

// EnterRoomReq

// optional string roomName = 1;
inline bool EnterRoomReq::has_roomname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterRoomReq::set_has_roomname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterRoomReq::clear_has_roomname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterRoomReq::clear_roomname() {
  if (roomname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomname_->clear();
  }
  clear_has_roomname();
}
inline const ::std::string& EnterRoomReq::roomname() const {
  // @@protoc_insertion_point(field_get:proto.EnterRoomReq.roomName)
  return *roomname_;
}
inline void EnterRoomReq::set_roomname(const ::std::string& value) {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomname_ = new ::std::string;
  }
  roomname_->assign(value);
  // @@protoc_insertion_point(field_set:proto.EnterRoomReq.roomName)
}
inline void EnterRoomReq::set_roomname(const char* value) {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomname_ = new ::std::string;
  }
  roomname_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.EnterRoomReq.roomName)
}
inline void EnterRoomReq::set_roomname(const char* value, size_t size) {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomname_ = new ::std::string;
  }
  roomname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.EnterRoomReq.roomName)
}
inline ::std::string* EnterRoomReq::mutable_roomname() {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.EnterRoomReq.roomName)
  return roomname_;
}
inline ::std::string* EnterRoomReq::release_roomname() {
  clear_has_roomname();
  if (roomname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = roomname_;
    roomname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EnterRoomReq::set_allocated_roomname(::std::string* roomname) {
  if (roomname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete roomname_;
  }
  if (roomname) {
    set_has_roomname();
    roomname_ = roomname;
  } else {
    clear_has_roomname();
    roomname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.EnterRoomReq.roomName)
}

// optional string nickName = 2;
inline bool EnterRoomReq::has_nickname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnterRoomReq::set_has_nickname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnterRoomReq::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnterRoomReq::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& EnterRoomReq::nickname() const {
  // @@protoc_insertion_point(field_get:proto.EnterRoomReq.nickName)
  return *nickname_;
}
inline void EnterRoomReq::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set:proto.EnterRoomReq.nickName)
}
inline void EnterRoomReq::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.EnterRoomReq.nickName)
}
inline void EnterRoomReq::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.EnterRoomReq.nickName)
}
inline ::std::string* EnterRoomReq::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.EnterRoomReq.nickName)
  return nickname_;
}
inline ::std::string* EnterRoomReq::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EnterRoomReq::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.EnterRoomReq.nickName)
}

// -------------------------------------------------------------------

// EnterRoomRsp

// optional int32 error = 1;
inline bool EnterRoomRsp::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterRoomRsp::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterRoomRsp::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterRoomRsp::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline ::google::protobuf::int32 EnterRoomRsp::error() const {
  // @@protoc_insertion_point(field_get:proto.EnterRoomRsp.error)
  return error_;
}
inline void EnterRoomRsp::set_error(::google::protobuf::int32 value) {
  set_has_error();
  error_ = value;
  // @@protoc_insertion_point(field_set:proto.EnterRoomRsp.error)
}

// optional uint32 ID = 2;
inline bool EnterRoomRsp::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnterRoomRsp::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnterRoomRsp::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnterRoomRsp::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 EnterRoomRsp::id() const {
  // @@protoc_insertion_point(field_get:proto.EnterRoomRsp.ID)
  return id_;
}
inline void EnterRoomRsp::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:proto.EnterRoomRsp.ID)
}

// -------------------------------------------------------------------

// MemberEnter

// optional uint32 ID = 1;
inline bool MemberEnter::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MemberEnter::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MemberEnter::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MemberEnter::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 MemberEnter::id() const {
  // @@protoc_insertion_point(field_get:proto.MemberEnter.ID)
  return id_;
}
inline void MemberEnter::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:proto.MemberEnter.ID)
}

// optional string nickName = 2;
inline bool MemberEnter::has_nickname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MemberEnter::set_has_nickname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MemberEnter::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MemberEnter::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& MemberEnter::nickname() const {
  // @@protoc_insertion_point(field_get:proto.MemberEnter.nickName)
  return *nickname_;
}
inline void MemberEnter::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set:proto.MemberEnter.nickName)
}
inline void MemberEnter::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.MemberEnter.nickName)
}
inline void MemberEnter::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.MemberEnter.nickName)
}
inline ::std::string* MemberEnter::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.MemberEnter.nickName)
  return nickname_;
}
inline ::std::string* MemberEnter::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MemberEnter::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.MemberEnter.nickName)
}

// -------------------------------------------------------------------

// UpMessage

// optional bytes message = 1;
inline bool UpMessage::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpMessage::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpMessage::clear_message() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& UpMessage::message() const {
  // @@protoc_insertion_point(field_get:proto.UpMessage.message)
  return *message_;
}
inline void UpMessage::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set:proto.UpMessage.message)
}
inline void UpMessage::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.UpMessage.message)
}
inline void UpMessage::set_message(const void* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.UpMessage.message)
}
inline ::std::string* UpMessage::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.UpMessage.message)
  return message_;
}
inline ::std::string* UpMessage::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UpMessage::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.UpMessage.message)
}

// optional int32 length = 2;
inline bool UpMessage::has_length() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpMessage::set_has_length() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpMessage::clear_has_length() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpMessage::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline ::google::protobuf::int32 UpMessage::length() const {
  // @@protoc_insertion_point(field_get:proto.UpMessage.length)
  return length_;
}
inline void UpMessage::set_length(::google::protobuf::int32 value) {
  set_has_length();
  length_ = value;
  // @@protoc_insertion_point(field_set:proto.UpMessage.length)
}

// -------------------------------------------------------------------

// DownMessage

// optional bytes message = 1;
inline bool DownMessage::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DownMessage::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DownMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DownMessage::clear_message() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& DownMessage::message() const {
  // @@protoc_insertion_point(field_get:proto.DownMessage.message)
  return *message_;
}
inline void DownMessage::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set:proto.DownMessage.message)
}
inline void DownMessage::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.DownMessage.message)
}
inline void DownMessage::set_message(const void* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.DownMessage.message)
}
inline ::std::string* DownMessage::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.DownMessage.message)
  return message_;
}
inline ::std::string* DownMessage::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DownMessage::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.DownMessage.message)
}

// optional int32 length = 2;
inline bool DownMessage::has_length() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DownMessage::set_has_length() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DownMessage::clear_has_length() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DownMessage::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline ::google::protobuf::int32 DownMessage::length() const {
  // @@protoc_insertion_point(field_get:proto.DownMessage.length)
  return length_;
}
inline void DownMessage::set_length(::google::protobuf::int32 value) {
  set_has_length();
  length_ = value;
  // @@protoc_insertion_point(field_set:proto.DownMessage.length)
}

// optional string nickName = 3;
inline bool DownMessage::has_nickname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DownMessage::set_has_nickname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DownMessage::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DownMessage::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& DownMessage::nickname() const {
  // @@protoc_insertion_point(field_get:proto.DownMessage.nickName)
  return *nickname_;
}
inline void DownMessage::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set:proto.DownMessage.nickName)
}
inline void DownMessage::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.DownMessage.nickName)
}
inline void DownMessage::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.DownMessage.nickName)
}
inline ::std::string* DownMessage::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.DownMessage.nickName)
  return nickname_;
}
inline ::std::string* DownMessage::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DownMessage::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.DownMessage.nickName)
}

// -------------------------------------------------------------------

// ExitRoomReq

// optional string roomName = 1;
inline bool ExitRoomReq::has_roomname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExitRoomReq::set_has_roomname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExitRoomReq::clear_has_roomname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExitRoomReq::clear_roomname() {
  if (roomname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomname_->clear();
  }
  clear_has_roomname();
}
inline const ::std::string& ExitRoomReq::roomname() const {
  // @@protoc_insertion_point(field_get:proto.ExitRoomReq.roomName)
  return *roomname_;
}
inline void ExitRoomReq::set_roomname(const ::std::string& value) {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomname_ = new ::std::string;
  }
  roomname_->assign(value);
  // @@protoc_insertion_point(field_set:proto.ExitRoomReq.roomName)
}
inline void ExitRoomReq::set_roomname(const char* value) {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomname_ = new ::std::string;
  }
  roomname_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.ExitRoomReq.roomName)
}
inline void ExitRoomReq::set_roomname(const char* value, size_t size) {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomname_ = new ::std::string;
  }
  roomname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.ExitRoomReq.roomName)
}
inline ::std::string* ExitRoomReq::mutable_roomname() {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.ExitRoomReq.roomName)
  return roomname_;
}
inline ::std::string* ExitRoomReq::release_roomname() {
  clear_has_roomname();
  if (roomname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = roomname_;
    roomname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExitRoomReq::set_allocated_roomname(::std::string* roomname) {
  if (roomname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete roomname_;
  }
  if (roomname) {
    set_has_roomname();
    roomname_ = roomname;
  } else {
    clear_has_roomname();
    roomname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ExitRoomReq.roomName)
}

// optional string nickName = 2;
inline bool ExitRoomReq::has_nickname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExitRoomReq::set_has_nickname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExitRoomReq::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExitRoomReq::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& ExitRoomReq::nickname() const {
  // @@protoc_insertion_point(field_get:proto.ExitRoomReq.nickName)
  return *nickname_;
}
inline void ExitRoomReq::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set:proto.ExitRoomReq.nickName)
}
inline void ExitRoomReq::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.ExitRoomReq.nickName)
}
inline void ExitRoomReq::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.ExitRoomReq.nickName)
}
inline ::std::string* ExitRoomReq::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.ExitRoomReq.nickName)
  return nickname_;
}
inline ::std::string* ExitRoomReq::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExitRoomReq::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ExitRoomReq.nickName)
}

// -------------------------------------------------------------------

// ExitRoomRsp

// optional int32 error = 1;
inline bool ExitRoomRsp::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExitRoomRsp::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExitRoomRsp::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExitRoomRsp::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline ::google::protobuf::int32 ExitRoomRsp::error() const {
  // @@protoc_insertion_point(field_get:proto.ExitRoomRsp.error)
  return error_;
}
inline void ExitRoomRsp::set_error(::google::protobuf::int32 value) {
  set_has_error();
  error_ = value;
  // @@protoc_insertion_point(field_set:proto.ExitRoomRsp.error)
}

// -------------------------------------------------------------------

// Message

// optional .proto.Message.MessageType type = 1;
inline bool Message::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::proto::Message_MessageType Message::type() const {
  // @@protoc_insertion_point(field_get:proto.Message.type)
  return static_cast< ::proto::Message_MessageType >(type_);
}
inline void Message::set_type(::proto::Message_MessageType value) {
  assert(::proto::Message_MessageType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:proto.Message.type)
}

// optional .proto.EnterRoomReq enterRoomReq = 2;
inline bool Message::has_enterroomreq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message::set_has_enterroomreq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message::clear_has_enterroomreq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message::clear_enterroomreq() {
  if (enterroomreq_ != NULL) enterroomreq_->::proto::EnterRoomReq::Clear();
  clear_has_enterroomreq();
}
inline const ::proto::EnterRoomReq& Message::enterroomreq() const {
  // @@protoc_insertion_point(field_get:proto.Message.enterRoomReq)
  return enterroomreq_ != NULL ? *enterroomreq_ : *default_instance_->enterroomreq_;
}
inline ::proto::EnterRoomReq* Message::mutable_enterroomreq() {
  set_has_enterroomreq();
  if (enterroomreq_ == NULL) enterroomreq_ = new ::proto::EnterRoomReq;
  // @@protoc_insertion_point(field_mutable:proto.Message.enterRoomReq)
  return enterroomreq_;
}
inline ::proto::EnterRoomReq* Message::release_enterroomreq() {
  clear_has_enterroomreq();
  ::proto::EnterRoomReq* temp = enterroomreq_;
  enterroomreq_ = NULL;
  return temp;
}
inline void Message::set_allocated_enterroomreq(::proto::EnterRoomReq* enterroomreq) {
  delete enterroomreq_;
  enterroomreq_ = enterroomreq;
  if (enterroomreq) {
    set_has_enterroomreq();
  } else {
    clear_has_enterroomreq();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.Message.enterRoomReq)
}

// optional .proto.EnterRoomRsp enterRoomRsp = 3;
inline bool Message::has_enterroomrsp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message::set_has_enterroomrsp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message::clear_has_enterroomrsp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message::clear_enterroomrsp() {
  if (enterroomrsp_ != NULL) enterroomrsp_->::proto::EnterRoomRsp::Clear();
  clear_has_enterroomrsp();
}
inline const ::proto::EnterRoomRsp& Message::enterroomrsp() const {
  // @@protoc_insertion_point(field_get:proto.Message.enterRoomRsp)
  return enterroomrsp_ != NULL ? *enterroomrsp_ : *default_instance_->enterroomrsp_;
}
inline ::proto::EnterRoomRsp* Message::mutable_enterroomrsp() {
  set_has_enterroomrsp();
  if (enterroomrsp_ == NULL) enterroomrsp_ = new ::proto::EnterRoomRsp;
  // @@protoc_insertion_point(field_mutable:proto.Message.enterRoomRsp)
  return enterroomrsp_;
}
inline ::proto::EnterRoomRsp* Message::release_enterroomrsp() {
  clear_has_enterroomrsp();
  ::proto::EnterRoomRsp* temp = enterroomrsp_;
  enterroomrsp_ = NULL;
  return temp;
}
inline void Message::set_allocated_enterroomrsp(::proto::EnterRoomRsp* enterroomrsp) {
  delete enterroomrsp_;
  enterroomrsp_ = enterroomrsp;
  if (enterroomrsp) {
    set_has_enterroomrsp();
  } else {
    clear_has_enterroomrsp();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.Message.enterRoomRsp)
}

// optional .proto.MemberEnter memberEnter = 4;
inline bool Message::has_memberenter() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Message::set_has_memberenter() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Message::clear_has_memberenter() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Message::clear_memberenter() {
  if (memberenter_ != NULL) memberenter_->::proto::MemberEnter::Clear();
  clear_has_memberenter();
}
inline const ::proto::MemberEnter& Message::memberenter() const {
  // @@protoc_insertion_point(field_get:proto.Message.memberEnter)
  return memberenter_ != NULL ? *memberenter_ : *default_instance_->memberenter_;
}
inline ::proto::MemberEnter* Message::mutable_memberenter() {
  set_has_memberenter();
  if (memberenter_ == NULL) memberenter_ = new ::proto::MemberEnter;
  // @@protoc_insertion_point(field_mutable:proto.Message.memberEnter)
  return memberenter_;
}
inline ::proto::MemberEnter* Message::release_memberenter() {
  clear_has_memberenter();
  ::proto::MemberEnter* temp = memberenter_;
  memberenter_ = NULL;
  return temp;
}
inline void Message::set_allocated_memberenter(::proto::MemberEnter* memberenter) {
  delete memberenter_;
  memberenter_ = memberenter;
  if (memberenter) {
    set_has_memberenter();
  } else {
    clear_has_memberenter();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.Message.memberEnter)
}

// optional .proto.UpMessage upMessage = 5;
inline bool Message::has_upmessage() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Message::set_has_upmessage() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Message::clear_has_upmessage() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Message::clear_upmessage() {
  if (upmessage_ != NULL) upmessage_->::proto::UpMessage::Clear();
  clear_has_upmessage();
}
inline const ::proto::UpMessage& Message::upmessage() const {
  // @@protoc_insertion_point(field_get:proto.Message.upMessage)
  return upmessage_ != NULL ? *upmessage_ : *default_instance_->upmessage_;
}
inline ::proto::UpMessage* Message::mutable_upmessage() {
  set_has_upmessage();
  if (upmessage_ == NULL) upmessage_ = new ::proto::UpMessage;
  // @@protoc_insertion_point(field_mutable:proto.Message.upMessage)
  return upmessage_;
}
inline ::proto::UpMessage* Message::release_upmessage() {
  clear_has_upmessage();
  ::proto::UpMessage* temp = upmessage_;
  upmessage_ = NULL;
  return temp;
}
inline void Message::set_allocated_upmessage(::proto::UpMessage* upmessage) {
  delete upmessage_;
  upmessage_ = upmessage;
  if (upmessage) {
    set_has_upmessage();
  } else {
    clear_has_upmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.Message.upMessage)
}

// optional .proto.DownMessage downMessage = 6;
inline bool Message::has_downmessage() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Message::set_has_downmessage() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Message::clear_has_downmessage() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Message::clear_downmessage() {
  if (downmessage_ != NULL) downmessage_->::proto::DownMessage::Clear();
  clear_has_downmessage();
}
inline const ::proto::DownMessage& Message::downmessage() const {
  // @@protoc_insertion_point(field_get:proto.Message.downMessage)
  return downmessage_ != NULL ? *downmessage_ : *default_instance_->downmessage_;
}
inline ::proto::DownMessage* Message::mutable_downmessage() {
  set_has_downmessage();
  if (downmessage_ == NULL) downmessage_ = new ::proto::DownMessage;
  // @@protoc_insertion_point(field_mutable:proto.Message.downMessage)
  return downmessage_;
}
inline ::proto::DownMessage* Message::release_downmessage() {
  clear_has_downmessage();
  ::proto::DownMessage* temp = downmessage_;
  downmessage_ = NULL;
  return temp;
}
inline void Message::set_allocated_downmessage(::proto::DownMessage* downmessage) {
  delete downmessage_;
  downmessage_ = downmessage;
  if (downmessage) {
    set_has_downmessage();
  } else {
    clear_has_downmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.Message.downMessage)
}

// optional .proto.ExitRoomReq exitRoomReq = 7;
inline bool Message::has_exitroomreq() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Message::set_has_exitroomreq() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Message::clear_has_exitroomreq() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Message::clear_exitroomreq() {
  if (exitroomreq_ != NULL) exitroomreq_->::proto::ExitRoomReq::Clear();
  clear_has_exitroomreq();
}
inline const ::proto::ExitRoomReq& Message::exitroomreq() const {
  // @@protoc_insertion_point(field_get:proto.Message.exitRoomReq)
  return exitroomreq_ != NULL ? *exitroomreq_ : *default_instance_->exitroomreq_;
}
inline ::proto::ExitRoomReq* Message::mutable_exitroomreq() {
  set_has_exitroomreq();
  if (exitroomreq_ == NULL) exitroomreq_ = new ::proto::ExitRoomReq;
  // @@protoc_insertion_point(field_mutable:proto.Message.exitRoomReq)
  return exitroomreq_;
}
inline ::proto::ExitRoomReq* Message::release_exitroomreq() {
  clear_has_exitroomreq();
  ::proto::ExitRoomReq* temp = exitroomreq_;
  exitroomreq_ = NULL;
  return temp;
}
inline void Message::set_allocated_exitroomreq(::proto::ExitRoomReq* exitroomreq) {
  delete exitroomreq_;
  exitroomreq_ = exitroomreq;
  if (exitroomreq) {
    set_has_exitroomreq();
  } else {
    clear_has_exitroomreq();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.Message.exitRoomReq)
}

// optional .proto.ExitRoomRsp exitRoomRsp = 8;
inline bool Message::has_exitroomrsp() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Message::set_has_exitroomrsp() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Message::clear_has_exitroomrsp() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Message::clear_exitroomrsp() {
  if (exitroomrsp_ != NULL) exitroomrsp_->::proto::ExitRoomRsp::Clear();
  clear_has_exitroomrsp();
}
inline const ::proto::ExitRoomRsp& Message::exitroomrsp() const {
  // @@protoc_insertion_point(field_get:proto.Message.exitRoomRsp)
  return exitroomrsp_ != NULL ? *exitroomrsp_ : *default_instance_->exitroomrsp_;
}
inline ::proto::ExitRoomRsp* Message::mutable_exitroomrsp() {
  set_has_exitroomrsp();
  if (exitroomrsp_ == NULL) exitroomrsp_ = new ::proto::ExitRoomRsp;
  // @@protoc_insertion_point(field_mutable:proto.Message.exitRoomRsp)
  return exitroomrsp_;
}
inline ::proto::ExitRoomRsp* Message::release_exitroomrsp() {
  clear_has_exitroomrsp();
  ::proto::ExitRoomRsp* temp = exitroomrsp_;
  exitroomrsp_ = NULL;
  return temp;
}
inline void Message::set_allocated_exitroomrsp(::proto::ExitRoomRsp* exitroomrsp) {
  delete exitroomrsp_;
  exitroomrsp_ = exitroomrsp;
  if (exitroomrsp) {
    set_has_exitroomrsp();
  } else {
    clear_has_exitroomrsp();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.Message.exitRoomRsp)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::proto::Message_MessageType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::Message_MessageType>() {
  return ::proto::Message_MessageType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_chatroom_2eproto__INCLUDED
